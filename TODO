# Docs

* Pros, cons, compromises, what it's for and what isn't
  - Point out there are many cases when the async isn't bottleneck.
* More examples
  - Including comparison with other methods, like threads, plain futures, futures-await, etc.
* A blog post, comparing and a case study

# Panicking/unwinding

* Catch unwinds from within the waited-on coroutines, and propagate them back
  to the coroutine, instead of killing the core (there's a future modifier for
  that)
* leak_on_panic support (currently, if the core is dropped because of a panic,
  the double-panics inside the coroutines cause abort, allow leaking in such
  case).

# Interface

* Something like select?
* Wait for future with timeout?
* Iterator that leaves the rest there on break
* Scoped spawns (so the data passed inside the closure don't have to be
  'static). Maybe call it join?
* Accept None as handle and spawn our own. Or, allow even others executors.
* Access to the builder that created this coroutine, so we can spawn with the
  same config (and provide default if we're not inside a coroutine)? This could
  be handy for libraries.
* Include some logging.

# Threads

It's impossible to do proper N:M threading scheme in Rust (or it seems). But it
*is* possible to pick a thread at coroutine creation and let it live its whole
life there.

There are questions, though:

* We probably want to have this as feature gate. Do we want to provide „dummy“
  implementation that doesn't go into background thread if not enabled?
* What is the preferred way? Have our own thread pool for coroutines, with
  lazily (or configurable-started) threads, and using thread futures-cpupool
  for the futures we wait for? Or have a core (or another executor) in each of
  the threads to place them there?
* Have a one, global pool or something like per-builder?
* Automatically send waited-on coroutines to the futures-cpupool if they're
  send?

# Misc

* Make the waits without allocating
  - Have a (handle-local) `FuturesUnordered`
  - Each coroutine pre-allocates one future in there.
  - The content may be either empty (the coroutine isn't waiting on anything),
    a pointer to the actual waited-on future (on the coroutine's stack) or Done,
    at which point it'll resolve.
  - We need to switch the content and notify it when needed.
  - There are some challenges with ensuring we know pointers both way and that
    nothing gets used after freeing. If possible without too many levels of
    indirection. Maybe something could be allocated at the bottom of the
    coroutine's stack?

# Tests

* More cores on the same thread, switching between them and killing some of the
  threads as it goes.
* Does it make sense to do some kind of fuzzying? How would that work, spawning
  random coroutines that randomly do something and yield?
* Benchmark how fast (or slow) the thing is, and copare to futures-only and
  futures-await scenarios.
  - There may be use cases where this is actually faster, because a lot of the
    above needs `'static` bounds.
